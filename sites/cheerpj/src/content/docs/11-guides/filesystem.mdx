---
title: Filesystem
description: Interacting with the virtual filesystem in CheerpJ
---

CheerpJ provides a **virtual filesystem** that allows your Java applications to perform file operations like reading and writing, just as they would on a desktop. This guide will explain how to effectively use CheerpJ's virtual filesystem, demonstrating how to transfer files between your Java application and the local JavaScript environment by focusing on common use cases.

> For a detailed overview of mounting points (`/app/`, `/files/`, `/str/`) and how they work, see the **[File and Filesystem guide](/docs/explanation/File-System-support)**.

> [!info] Local files
> CheerpJ provides access to a virtualized filesystem, which does not correspond to the local user's computer. For browser security reasons, direct access to local files is forbidden. This means your Java code running in CheerpJ cannot directly read or write files on the user's physical hard drive. All file interactions happen within this secure, virtual environment.

## Loading the files from JavaScript to the Virtual File System

Sometimes, your web page may have files (for example, uploaded by a user) that your Java application needs to read or process. You can transfer these files from JavaScript into CheerpJ’s virtual file system. This is useful in several scenarios:

- **External Applications:** Some Java applications expect files in specific paths (e.g., a hardcoded path like `filename.txt`). If you load a file into `/app/`, your Java code must reference it as  `/app/filename.txt`. But if you can’t modify the Java code, for example in an external application, loading the file into `/files/` makes it accessible simply as `"filename.txt"`. The `/files/` directory acts as a default working directory.
- **Dynamic Content:** You can provide configuration files or other runtime data from JavaScript directly to your Java application, without recompiling or modifying the Java code.
- **Binary Data:** The `cheerpOSAddStringFile` API (and the underlying `java.nio.file.Files.copy` method) supports binary files as well, allowing you to provide any file type to Java.

### Method 1: Using `cheerpOSAddStringFile` (string or binary).

The quickest way to place a file into CheerpJ’s virtual filesystem from JavaScript is `cheerpOSAddStringFile`. It’s ideal for string content and also supports binary data.

**When to call it:** Invoke `cheerpOSAddStringFile` after `cheerpjInit()` finishes (i.e., once its Promise resolves). The API depends on the runtime and VFS being fully initialized.

**Where the file goes:** The call creates a file under the `/str/` mount. Your Java code can then read it like any normal file path inside the application.

```js
// Call this only after cheerpjInit() has resolved.
async function addStringFileToCheerpJ() {
  const fileName = 
    document.getElementById("jsFileName").value.trim() || "default.txt";
  const content =
    document.getElementById("jsFileContent").value || "Default content.";
  const messageDiv = document.getElementById("jsMessage");

  try {
    // Using cheerpOSAddStringFile to add content to /str/
    await cheerpOSAddStringFile(`/str/${fileName}`, content);
    messageDiv.textContent = `Saved /str/${fileName}. (overwrites if existing)`;
    console.log(`Saved ${fileName} to /str/`);
  } catch (e) {
    messageDiv.textContent = `Failed to save /str/${fileName}: ${e.message}`;
    console.error("Error Writing file to /str/:", e);
  }
}
```

### Method 2: Using library mode

When a file already lives under `/app/` but your Java code needs to read it as if it were in `/files/` (i.e., without the `/app/` prefix), use library mode to copy it across mounts. With `cheerpjRunLibrary`, you can invoke Java’s `java.nio.file` from JavaScript to copy the file from `/app/…` to `/files/…`, after which the application can open it using just its bare filename.

```js
async function copyFileToFilesMountPoint() {
  // Library mode can be created before or after cheerpjInit
  const lib = await cheerpjRunLibrary(""); // Create a library mode object
  const Files = await lib.java.nio.file.Files;
  const StandardCopyOption = await lib.java.nio.file.StandardCopyOption;
  const Paths = await lib.java.nio.file.Paths;

  // Source is a file within the /app/ mount point
  const source = await Paths.get("/app/notes_tmp.txt");
  // Target is the /files/ mount point
  const target = await Paths.get("/files/notes_tmp.txt");

  try {
    await Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING]);
    console.log("Copied /app/notes_tmp.txt to /files/notes_tmp.txt");
  } catch (e) {
    console.error("Error copying file:", e);
  }
}

// Initializing CheerpJ and run your Java Application
async function cj3init() {
  await cheerpjInit({ version: 8 });
  // cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}

(async () => {
  await cj3init();
  await copyFileToFilesMountPoint();
})();

// Your Java app can now access "notes_tmp.txt" by simply calling `new File("notes_tmp.txt")`
// without needing the /app/ prefix.
```

**Explanation:**

- **`cheerpjRunLibrary("")`** Creates a library-mode object that lets you call Java’s `java.nio.file` APIs from JavaScript. See the [CheerpJ documentation](/docs/reference/cheerpjRunLibrary) for details.
- **`Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING])`** Copies a file from the `/app/` mount point to the `/files/` mount point. Using `REPLACE_EXISTING` ensures the target is overwritten if it already exists.
- **Accessing the file in Java:** After copying, your Java application can read it with `new File("notes_tmp.txt")`. No /app/ prefix is needed once the file is in /files/.

## Getting a file from the Virtual File System to JavaScript (i.e local file system)

A common scenario is that your Java application generates or updates a file and you need to make it available to the user. When running under CheerpJ, files saved by Java are written to the virtual filesystem, specifically the `/files/` mount **not** directly to the user’s local disk. The workflow for exposing the file to the browser (and then the user) is as follows:

1. **Java writes/generates the file:** Your Java application creates or saves the file under the `/files/` mount within CheerpJ’s virtual filesystem.
2. **Java invokes a JavaScript native method:** Since the file lives in the virtual filesystem, we implement a Java **native** method that is handled by JavaScript. To learn more about native methods, you can refer to the [CheerpJ tutorial on native methods](/docs/guides/implementing-native-methods.html).
3. **JavaScript retrieves and processes the file:** In the JavaScript implementation of the native method, retrieve the file's content from the virtual filesystem. You can then process the file in any way required by your web application. For example you can trigger a download by using the `cjFileBlob()` API to get the file's content as a `Blob` and then use standard browser APIs to trigger a download (as will be explained in a later section).

**Step 1 and 2: Java Writes the File and Calls a Native Method**

First, your Java application writes the file to CheerpJ’s virtual filesystem (the `/files/` mount). Next it calls a **native method** (implemented in JavaScript), which acts as a bridge to execute JavaScript code.

```java title="App.java"
// Declare the native method
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
try {
    // You can also use "example.txt" since it defaults to the /files/ mount point
    File file = new File("/files/example.txt");
    FileWriter writer = new FileWriter(file);
    writer.write(content);
    writer.close();

    // Pass the actual file path to the native method
    downloadFileFromCheerpJ(filepath);

} catch (IOException e) {
    System.err.println("Error generating or writing file: " + e.getMessage());
}
```

**Step 3: JavaScript Implements the Native Method and Downloads the File**

Now we’ll implement the JavaScript for `downloadFileFromCheerpJ`. The function receives the file path from Java, uses CheerpJ’s `cjFileBlob()` to get the file’s content, and then triggers a download using standard browser APIs.

```html "index.html"
<script>
// Native method implementation called from Java
// Naming: Java_<fully-qualified-class>_<method>
async function Java_com_App_downloadFileFromCheerpJ(
  lib, // CheerpJ's internal library object
  fileName // The file name passed from Java
  ) {
  // fileName can be "example.txt" or "/files/example.txt" (both resolve to the /files/ mount)
  console.log(`Attempting to download file: ${fileName}`);

  try {
    // Read the file from CheerpJ's virtual filesystem as a Blob
    const blob = await cjFileBlob(`${fileName}`);

    // Create a temporary object URL for the Blob so the browser can download it
    const url = URL.createObjectURL(blob);

    // Create an anchor element and set the download target
    const a = document.createElement("a");
    a.href = url;

    // Use the last path segment as the download filename
    a.download = fileName.split("/").pop() || "download";

    // Add to the DOM, click it programmatically to start download, then remove
    document.body.appendChild(a);
    a.click();
    a.remove();

    // Clean up the temporary object URL
    URL.revokeObjectURL(url);

    console.log(`Successfully downloaded ${fileName}`);
  } catch (e) {
    console.error("Error downloading file:", e);
    alert("Failed to download the file. See console for details.");
  }
}

// Initialize CheerpJ and register the native method
async function cj3init() {
  await cheerpjInit({
    // Register native method
    natives: { Java_com_App_downloadFileFromCheerpJ },
  });

  // cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}
cj3init();
</script>
```

**Explanation:**

- **Native method naming convention:** The JavaScript function name must follow `Java_<fully-qualified-class-name>_<method-name>` CheerpJ uses this pattern to bind a Java `native` method call to the correct JS implementation.
- **`cjFileBlob(filePath)`:** CheerpJ API that reads a file from the virtual filesystem (`/files/`, `/app/`, or `/str/`) and returns its contents as a `Blob`.
- **Blob and download flow:** After you have the `Blob`, use standard browser APIs to trigger a download:
  1. Create a temporary URL with `URL.createObjectURL(blob)`.
  2. Create an `<a>` element, set `a.href` to that URL.
  3. Set `a.download` to suggest the filename.
  4. Click the link programmatically to start the download.
  5. Call `URL.revokeObjectURL(...)` to release the temporary URL.
- **Registering natives in `cheerpjInit`:** Use the `natives` option to register your JavaScript native implementations so they’re callable from your Java code.

## Using Java's `JFileChooser` with CheerpJ

Java applications often use `JFileChooser` for "Save As..." dialogues. CheerpJ supports `JFileChooser`, and when a user selects a file name, that name is used within the virtual filesystem. You can then use this name to trigger a download using the native method approach described in Section 2.

When you instantiate `JFileChooser` in your Java code, it operates on CheerpJ's virtual filesystem. You instantiate it without arguments (`JFileChooser fileChooser = new JFileChooser();`), to open the dialog in the default directory: `/files/`.

Here is how the dialog will look like when you use `JFileChooser` in CheerpJ with the default `/files/` mount point:
![](/docs/cheerpj3/assets/filechooser.png)

**Java Source Code: Essential `JFileChooser` and Download Logic**

```java title="App.java"

// (Retain the native method declaration from Section 2)
public static native void downloadFileFromCheerpJ(String filePath);

// Button to trigger the JFileChooser
JButton chooseDownloadButton = new JButton("Choose File to Download");

chooseDownloadButton.addActionListener((ActionEvent e) -> {
    // 1. Instantiate JFileChooser, initially pointing to the /files/ mount point.
    JFileChooser fileChooser = new JFileChooser("/files/");
    fileChooser.setDialogTitle("Select file to download");
    // 2. Show the save dialog to let the user select a file.
    int result = fileChooser.showSaveDialog(this);
    // 3. Check if the user approved the selection (didn't cancel).
    if (result == JFileChooser.APPROVE_OPTION) {
        // 4. Get the selected file from the file chooser.
        // For example, if you wrote "Hello World" to /files/example.txt, "/files/example.txt" will be the selected file.
        // 5. Get the path of the selected file.
        File selectedFile = fileChooser.getSelectedFile();
        String filePath = selectedFile.getPath();
        // 6. Call the native JavaScript method to download the file from the virtual filesystem.
        downloadFileFromCheerpJ(filePath);
    }
});
```

**Explanation:**

- `new JFileChooser("/files/")`: This initializes the file chooser to start Browse from the `/files/` directory within CheerpJ's virtual filesystem. This is important because `/files/` is the writable and persistent mount point.
- `fileChooser.showSaveDialog(this)`: This method displays the file chooser dialog, allowing the user to select a save location and filename. `showOpenDialog` would be used for opening existing files.
- `fileChooser.getSelectedFile().getPath()`: If the user approves the selection, this returns the full path (e.g., `/files/myDocument.txt`) that the user specified.
- `downloadFileFromCheerpJ(filePath)`: We reuse the same native method from Section 2. Once the user has selected a path, you would ensure your Java application writes its data to that `filePath` within the virtual filesystem, and then you would call this native method to trigger the download to the user's local machine.

**HTML and JavaScript Code (`index.html`)**

The HTML and JavaScript for handling the download are essentially the **same as in Section 2**.

## Special Case: For Applets using `showDocument()`

For **Applets**, `AppletContext.showDocument()` can be used as a workaround for downloads, although native methods are generally more flexible.

- **Direct URL Download**: If the file you want to download is already available at a public URL (e.g., hosted on your server), you can simply use `showDocument()` to point to that URL, and the browser will handle the download.

  ```java
  // Java Applet Code
  private void downloadDirectURL() {
      try {
          // Assumes 'example.txt' is in the same directory as the applet JAR
          URL fileUrl = new URL(getCodeBase().getProtocol(),
                                getCodeBase().getHost(),
                                getCodeBase().getPort(),
                                "/example.txt");
          getAppletContext().showDocument(fileUrl, "_blank"); // "_blank" will trigger download
          System.out.println("Triggered direct URL download: " + fileUrl.toString());
      } catch (Exception ex) {
          ex.printStackTrace();
          JOptionPane.showMessageDialog(null, "Error downloading from URL: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
      }
  }
  ```

- **Executing JavaScript for Dynamic Content**: You can use `showDocument()` to execute arbitrary JavaScript code that then handles a download. This is less common but can be useful for passing dynamically generated content from Java to JavaScript for download.

  ```java
  // Java Applet Code
  private void downloadViaJavaScriptShowDocument() {
      try {
          String content = "Dynamic content generated in Java!";
          String encodedContent = URLEncoder.encode(content, "UTF-8").replace("+", "%20"); // Encode for URL
          AppletContext context = getAppletContext();
          // Call a JavaScript function 'downloadFromJava' and pass content
          context.showDocument(new URL("javascript:downloadFromJava('" + encodedContent + "')"));
          System.out.println("Triggered JS download via showDocument.");
      } catch (Exception ex) {
          ex.printStackTrace();
      }
  }
  ```

  And in your HTML, you'd have the `downloadFromJava` JavaScript function:

  ```javascript
  // JavaScript in applet.html
  function downloadFromJava(encodedContent) {
  	const content = decodeURIComponent(encodedContent);
  	const blob = new Blob([content], { type: "text/plain" });
  	const url = URL.createObjectURL(blob);

  	const a = document.createElement("a");
  	a.href = url;
  	a.download = "applet_showdocument_dynamic.txt";
  	document.body.appendChild(a);
  	a.click();
  	document.body.removeChild(a);
  	URL.revokeObjectURL(url);
  	console.log("File downloaded via showDocument (JS)");
  }
  ```
