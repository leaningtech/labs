---
title: Filesystem
description: Interacting with the virtual filesystem in CheerpJ
---

CheerpJ provides a **virtual filesystem** that lets your Java application read and write files inside a secure, browser-sandboxed environment. For browser security reasons, it cannot access the user’s actual local disk. All file operations happen within this virtual space, which provides multiple mounting points so your application can behave much like it would on a regular filesystem.

**Mounting points overview**

- **`/app/`** — Read-only mount that points to the root of your web server. Java can read the files using the '/app/' prefix.
- **`/files/`** — Persistent, Java read-write area and the default mounting point for Java. JavaScript can read via CheerpJ APIs.
- **`/str/`** — Accessible mount used to pass data from JavaScript to Java. JavaScript can read and write, Java can only read. Not persisted.

If a file is served by your HTTP server (e.g., alongside your JARs), your Java code can read it via the `/app` prefix. For any other local files, it is necessary to load them into the virtual filesystem first. Either `/str` (inject from JavaScript) or `/files` (read/write at runtime). CheerpJ provides several ways to move files into and out of this virtual filesystem.

> For a detailed overview of mounting points (`/app/`, `/files/`, `/str/`) and how they work, see the **[File and Filesystem guide](/docs/explanation/File-System-support)**.

## Loading Files from JavaScript into the Virtual Filesystem

While your application runs under **CheerpJ**, any page-provided assets must first be placed in the **virtual filesystem** for Java to access them. Expose them from JavaScript to the `/str/` mount either through [`cheerpOSAddStringFile`](/docs/reference/cheerpOSAddStringFile) or using [Library Mode](/docs/guides/implementing-native-libraries), and then read them from your Java code like regular files.

### Method 1: Using `cheerpOSAddStringFile` (string or binary).

The quickest way to place a file into CheerpJ’s virtual filesystem from JavaScript is `cheerpOSAddStringFile`. It’s ideal for string content and also supports binary data.

**When to call it:** Invoke `cheerpOSAddStringFile` after `cheerpjInit()` finishes (i.e., once its Promise resolves). The API depends on the runtime and virtual file system being fully initialized.

```js
// Call this only after cheerpjInit() has resolved.
async function addStringFileToCheerpJ() {
	const fileName = "default.txt";
	const content = "Default content.";

	try {
		await cheerpOSAddStringFile(`/str/${fileName}`, content);
		console.log(`File "${fileName}" added to /str/.`);
	} catch (e) {
		console.error("Error writing file to /str/:", e);
	}
}
```

Entries you create under **`/str/`** (from JavaScript) are readable from Java as regular files. Remember: `/str/` is **not persisted** and is **read-only** from Java.

```java title="App.java"
import java.nio.file.Files;
import java.nio.file.Path;
/*
Rest of your Java code...
*/
String text = Files.readString(Path.of("/str/fileName.txt"));
System.out.println(text);
```

### Method 2: Using library mode

When a file already lives under `/app/` but your Java code needs to read it as if it were in `/files/` (i.e., without the `/app/` prefix), use [libraries mode](/docs/guides/library-mode) to copy it across mounts. With [`cheerpjRunLibrary`](/docs/reference/cheerpjRunLibrary), you can invoke Java’s `java.nio.file` from JavaScript to copy the file from `/app/…` to `/files/…`, after which the application can open it using just its bare filename.

```js
async function copyFileToFilesMountPoint() {
	// Library mode can be created before or after cheerpjInit
	const lib = await cheerpjRunLibrary(""); // Create a library mode object
	const Files = await lib.java.nio.file.Files;
	const StandardCopyOption = await lib.java.nio.file.StandardCopyOption;
	const Paths = await lib.java.nio.file.Paths;

	const source = await Paths.get("/app/notes_tmp.txt");
	const target = await Paths.get("/files/notes_tmp.txt");

	try {
		await Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING]);
		console.log("Copied /app/notes_tmp.txt to /files/notes_tmp.txt");
	} catch (e) {
		console.error("Error copying file:", e);
	}
}

// Then, initialize CheerpJ and run your Java application
async function cj3init() {
	await cheerpjInit({
		version: 8,
	});
	// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}
cj3init();
copyFileToFilesMountPoint();
// Your Java app can now access "notes_tmp.txt" by simply calling `new File("notes_tmp.txt")`
// without needing the /app/ prefix.
```

## Getting a file from the Virtual File System to JavaScript (i.e local file system)

When Java runs under **CheerpJ**, files are saved to the **virtual filesystem** (default **`/files/`**), not the user’s disk. You can expose these files to the page either directly from JavaScript or by handing off from Java to JavaScript via a native method.

### Method 1: Using `cjFileBlob`

Use the JavaScript-accessible [cjFileBlob API](/docs/reference/cjFileBlob) to extract files from the virtual file system. Java writes the file into `/files/`, and JavaScript reads it and triggers a download.

```html title="index.html"
<button id="download">Download file</button>
<script type="module">
	document.getElementById("download").addEventListener("click", async () => {
		try {
			const fileName = "example.txt"; // written by Java
			const path = "/files/" + fileName;
			const blob = await cjFileBlob(path); // read from VFS
			const url = URL.createObjectURL(blob);

			const link = document.createElement("a");
			link.href = url;
			link.download = fileName;
			link.click();

			URL.revokeObjectURL(url);
			console.log(`Successfully downloaded ${fileName}`);
		} catch (e) {
			console.error("Error downloading file:", e);
		}
	});
</script>
```

### Method 2: Call a JavaScript native method from Java

Use this when the **Java** code should decide when to save/preview/upload. Java writes the file to `/files/` and calls a native method (implemented in JavaScript) to perform the browser action.

**Java Writes the File and Calls a Native Method**

```java title="App.java"
// Declare the native method
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
try {
    // You can also use "example.txt" since it defaults to the /files/ mount point
    File file = new File("/files/example.txt");
    FileWriter writer = new FileWriter(file);
    writer.write(content);
    writer.close();

    // Pass the actual file path to the native method
    downloadFileFromCheerpJ(filepath);

} catch (IOException e) {
    System.err.println("Error generating or writing file: " + e.getMessage());
}
```

**JavaScript Implements the Native Method and Downloads the File**

Now we’ll implement the [native method](/docs/guides/implementing-native-methods) `downloadFileFromCheerpJ` in JavaScript to process the file. The function receives the file path from Java, uses CheerpJ’s `cjFileBlob()` to get the file’s content, and then triggers a download using standard browser APIs.

```js
// Native method implementation called from Java
// Naming: Java_<fully-qualified-class>_<method>
async function Java_App_downloadFileFromCheerpJ(lib, fileName) {
	try {
		// Read the file from CheerpJ's virtual filesystem as a Blob
		const blob = await cjFileBlob("/files/" + fileName);

		// Create an invisible link
		const link = document.createElement("a");
		link.href = URL.createObjectURL(blob);
		link.download = fileName;

		// Simulate a click on the link and clean up objects
		link.click();
		link.remove();
		URL.revokeObjectURL(url);

		console.log(`Successfully downloaded ${fileName}`);
	} catch (e) {
		console.error("Error downloading file:", e);
	}
}

// Initialize CheerpJ and register the native method
async function cj3init() {
	await cheerpjInit({
		// Register native method
		natives: { Java_App_downloadFileFromCheerpJ },
	});
	// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}
cj3init();
```

## Using Java's `JFileChooser` with CheerpJ

`JFileChooser` works the same under CheerpJ, but it targets the **virtual filesystem**. By default the dialog opens in `/files/` mount (the writable, persistent area), so any file you open or save is referenced by a virtual file system path (e.g., `/files/report.txt`) rather than the user’s physical disk.

Here is how the dialog will look like when you use `JFileChooser` in CheerpJ with the default `/files/` mount point:
![](/docs/cheerpj3/assets/filechooser.png)

You can still perform normal Java file operations with CheerpJ. The paths simply refer to the virtual filesystem rather than the user’s physical disk.

To access local files, first import them into the virtual file system (see previous section). To save or download files to the user’s machine from Java, you can utilize a JavaScript native method again.

**Java Source Code: `JFileChooser` and Download Logic**

```js title="App.java"
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
JFileChooser fileChooser = new JFileChooser();
int result = fileChooser.showOpenDialog(null);

// User confirmed file selection
if (result == JFileChooser.APPROVE_OPTION) {
  File selectedFile = fileChooser.getSelectedFile();
  String filePath = selectedFile.getPath();

  // Trigger the native JavaScript function that handles the file
  downloadFileFromCheerpJ(filePath);
}
```

The JavaScript code for handling the download is essentially the same as the Step 3 code of **[Getting the file from the virtual file system to JavaScript](/docs/guides/filesystem#getting-a-file-from-the-virtual-file-system-to-javascript-ie-local-file-system)**.

## Special Case: Applets using `showDocument()`

For **Applets**, `AppletContext.showDocument()` can be used as a lightweight workaround to trigger downloads. This can be handy, but the **native-method approach** remains more flexible and robust for most cases.

### Method 1: Direct URL download

If the file is already available at a public URL (e.g., on your server), point `showDocument()` at that URL.

```java
// Java Applet Code
private void downloadDirectURL() {
  try {
    // Assumes 'filename.txt' is in the same directory as the applet JAR
    URL fileUrl = new URL(getCodeBase()+"filename.txt");
    getAppletContext().showDocument(fileUrl, "_blank");

    System.out.println("Triggered direct URL download: " + fileUrl.toString());
  } catch (Exception ex) {
    ex.printStackTrace();
  }
}
```

### Method 2: Execute JavaScript for dynamic content

You can use `showDocument()` to execute arbitrary JavaScript code that then handles a download. This is less common but can be useful for passing dynamically generated content from Java to JavaScript for download.

```java
// Java Applet Code
private void downloadViaJavaScriptShowDocument() {
  try {
      String content = "Dynamic content generated in Java!";
      String encodedContent = URLEncoder.encode(content, "UTF-8").replace("+", "%20"); // Encode for URL
      AppletContext context = getAppletContext();

      // Call a JavaScript function 'downloadFromJava' and pass content
      context.showDocument(new URL("javascript:downloadFromJava('" + encodedContent + "')"));
      System.out.println("Triggered JS download via showDocument.");
  } catch (Exception ex) {
      ex.printStackTrace();
  }
}
```

And in your HTML, you'd have the `downloadFromJava` JavaScript function:

```javascript
// JavaScript in applet.html
function downloadFromJava(encodedContent) {
	try {
		const content = decodeURIComponent(encodedContent);
		const blob = new Blob([content], { type: "text/plain" });
		const url = URL.createObjectURL(blob);

		// Create an invisible link
		const link = document.createElement("a");
		link.href = url;
		link.download = "applet_showdocument_dynamic.txt";

		// Simulate a click on the link and clean up objects
		link.click();
		link.remove();
		URL.revokeObjectURL(url);

		console.log("File downloaded via showDocument");
	} catch (e) {
		console.error("Error downloading file:", e);
	}
}
```
