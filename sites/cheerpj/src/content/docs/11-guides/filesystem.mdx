---
title: Filesystem
description: Interacting with the virtual filesystem in CheerpJ
---

CheerpJ provides a **virtual filesystem** that allows your Java applications to perform file operations like reading and writing, just as they would on a desktop. This guide will explain how to effectively use CheerpJ's virtual filesystem, demonstrating how to transfer files between your Java application and the local JavaScript environment by focusing on common use cases.

> For a detailed overview of mounting points (`/app/`, `/files/`, `/str/`) and how they work, see the **[File and Filesystem guide](/docs/explanation/File-System-support)**.

> [!info] Local files
> CheerpJ provides access to a virtualized filesystem, which does not correspond to the local user's computer. For browser security reasons, direct access to local files is forbidden. This means your Java code running in CheerpJ cannot directly read or write files on the user's physical hard drive. All file interactions happen within this secure, virtual environment.

## Loading the files from JavaScript to the virtual file system

Sometimes, your web page may have files (for example, uploaded by a user) that your Java application needs to read or process. You can transfer these files from JavaScript into CheerpJ’s virtual file system. This is useful in several scenarios:

- **External Applications:** Some Java applications expect files in specific paths (e.g., a hardcoded path like `filename.txt`). If you load a file into `/app/`, your Java code must reference it as  `/app/filename.txt`. But if you can’t modify the Java code, for example in an external application, loading the file into `/files/` makes it accessible simply as `"filename.txt"`. The `/files/` directory acts as a default working directory.
- **Dynamic Content:** You can provide configuration files or other runtime data from JavaScript directly to your Java application, without recompiling or modifying the Java code.
- **Binary Data:** The `cheerpOSAddStringFile` API (and the underlying `java.nio.file.Files.copy` method) supports binary files as well, allowing you to provide any file type to Java.

### Method 1: Using `cheerpOSAddStringFile` (string or binary).

The quickest way to place a file into CheerpJ’s virtual filesystem from JavaScript is `cheerpOSAddStringFile`. It’s ideal for string content and also supports binary data.

**When to call it:** Invoke `cheerpOSAddStringFile` after `cheerpjInit()` finishes (i.e., once its Promise resolves). The API depends on the runtime and VFS being fully initialized.

**Where the file goes:** The call creates a file under the `/str/` mount. Your Java code can then read it like any normal file path inside the application.

```js
// Call this only after cheerpjInit() has resolved.
async function addStringFileToCheerpJ() {
  const fileName = 
    document.getElementById("jsFileName").value.trim() || "default.txt";
  const content =
    document.getElementById("jsFileContent").value || "Default content.";
  const messageDiv = document.getElementById("jsMessage");

  try {
    // Using cheerpOSAddStringFile to add content to /str/
    await cheerpOSAddStringFile(`/str/${fileName}`, content);
    messageDiv.textContent = `Saved /str/${fileName}. (overwrites if existing)`;
    console.log(`Saved ${fileName} to /str/`);
  } catch (e) {
    messageDiv.textContent = `Failed to save /str/${fileName}: ${e.message}`;
    console.error("Error Writing file to /str/:", e);
  }
}
```

### Method 2: Using library mode

When a file already lives under `/app/` but your Java code needs to read it as if it were in `/files/` (i.e., without the `/app/` prefix), use library mode to copy it across mounts. With `cheerpjRunLibrary`, you can invoke Java’s `java.nio.file` from JavaScript to copy the file from `/app/…` to `/files/…`, after which the application can open it using just its bare filename.

```js
async function copyFileToFilesMountPoint() {
  // Library mode can be created before or after cheerpjInit
  const lib = await cheerpjRunLibrary(""); // Create a library mode object
  const Files = await lib.java.nio.file.Files;
  const StandardCopyOption = await lib.java.nio.file.StandardCopyOption;
  const Paths = await lib.java.nio.file.Paths;

  // Source is a file within the /app/ mount point
  const source = await Paths.get("/app/notes_tmp.txt");
  // Target is the /files/ mount point
  const target = await Paths.get("/files/notes_tmp.txt");

  try {
    await Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING]);
    console.log("Copied /app/notes_tmp.txt to /files/notes_tmp.txt");
  } catch (e) {
    console.error("Error copying file:", e);
  }
}

// Initializing CheerpJ and run your Java Application
async function cj3init() {
  await cheerpjInit({ version: 8 });
  // cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}

(async () => {
  await cj3init();
  await copyFileToFilesMountPoint();
})();

// Your Java app can now access "notes_tmp.txt" by simply calling `new File("notes_tmp.txt")`
// without needing the /app/ prefix.
```

**Explanation:**

- **`cheerpjRunLibrary("")`** Creates a library-mode object that lets you call Java’s `java.nio.file` APIs from JavaScript. See the [CheerpJ documentation](/docs/reference/cheerpjRunLibrary) for details.
- **`Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING])`** Copies a file from the `/app/` mount point to the `/files/` mount point. Using `REPLACE_EXISTING` ensures the target is overwritten if it already exists.
- **Accessing the file in Java:** After copying, your Java application can read it with `new File("notes_tmp.txt")`. No /app/ prefix is needed once the file is in /files/.

## Getting the file from the virtual file system to the local file system (i.e JavaScript)

This is a very common requirement: your Java application generates or modifies a file, and you need to access the file locally. It's important to note that when your Java application saves a file while running with CheerpJ, this file will be written to CheerpJ's virtual filesystem (the /files/ mount point) rather than directly to the user's local file system. The general workflow for then making this file available to the user is as follows:

1.  **Java writes/generates a file:** Your Java application creates or saves a file to the `/files/` mounting point within CheerpJ's virtual filesystem.
2.  **Java calls a JavaScript native method:** Since the file is in the virtual filesystem, we can implement a native to retrieve it in JavaScript.
    To learn more about native methods, you can refer to the [CheerpJ tutorial on native methods](/docs/guides/implementing-native-methods.html).
3.  **JavaScript retrieves and processes the file:** The JavaScript native method retrieves the file's content from the virtual filesystem. At this point, the JavaScript native code can process the file in any way required by your web application. For example you can trigger a download by using the `cjFileBlob()` API to get the file's content as a `Blob` and then use standard browser APIs to trigger a download (as will be explained in a later section).

**Step 1: Java Writes the File and Calls a Native Method**

First, your Java application needs to write the file to CheerpJ's virtual filesystem, specifically to the `/files/` mount point. Once the file is written, Java can call a _native method_ which acts as a bridge to execute JavaScript code.

```java title="App.java" {7}
public static native void downloadFileFromCheerpJ(String filePath); // Declare the native method
/*
Rest of your Java code...
*/
try {
    File file = new File("/files/example.txt"); // You can also use "example.txt" since it defaults to the /files/ mount point
    FileWriter writer = new FileWriter(file);
    writer.write(content);
    writer.close();

    downloadFileFromCheerpJ(filePath);

} catch (IOException e) {
    System.err.println("Error generating or writing file: " + e.getMessage());
}
```

**Step 2: JavaScript Implements the Native Method and Downloads the File**

Now, we need to provide the JavaScript implementation for the `downloadFileFromCheerpJ` native method. This JavaScript function will receive the file path from Java, use CheerpJ's `cjFileBlob()` API to get the file's content, and then use standard browser APIs to trigger a download.

```javascript title="index.html"
// JavaScript implementation of the native method
// The naming convention is Java_<fully-qualified-class-name>_<method-name>
async function Java_com_App_downloadFileFromCheerpJ(
	lib, // CheerpJ's internal library object (usually not needed here)
	fileName // The file name passed from Java
) {
	console.log(`Attempting to download file: ${fileName}`);
	try {
		// 3. Use cjFileBlob() to get the file content as a Blob
		const blob = await cjFileBlob(`${fileName}`);
		const link = document.createElement("a");
		link.href = URL.createObjectURL(blob);
		// Set the downloaded file name as the last part of the path
		link.download = fileName.split("/").pop(); // Extract the file name from the path
		document.body.appendChild(link); // Append to body to make it clickable
		link.click(); // Programmatically click the link to trigger download
		document.body.removeChild(link); // Clean up
		URL.revokeObjectURL(link.href); // Release the object URL
		console.log(`Successfully downloaded ${fileName}`);
	} catch (e) {
		console.error("Error downloading file:", e);
		alert("Failed to download file. Check console for details.");
	}
}

// Initialize CheerpJ and run the Java application
async function cj3init() {
	await cheerpjInit({
		version: 8,
		// Register the native method
		natives: {
			Java_com_App_downloadFileFromCheerpJ,
		},
	});
	// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}
cj3init();
```

**Explanation:**

- **Native Method Naming Convention**: The JavaScript function name must follow the pattern `Java_<fully-qualified-class-name>_<method-name>`. This is how CheerpJ links your Java native method call to the correct JavaScript function.
- `cjFileBlob(filePath)`: This CheerpJ API is the bridge between the virtual filesystem and JavaScript. It takes the path to a file within `/files/` (or `/app/`, `/str/`) and returns its content as a `Blob`.
- **Blob and Download**: Once you have the `Blob`, standard browser techniques are used to create a temporary download link and simulate a click, prompting the user to save the file. `URL.createObjectURL(blob)` generates a temporary URL for the blob, and `link.download` suggests a filename to the browser.
- **`natives` Object in `cheerpjInit`**: This is where you register all your custom JavaScript native methods with CheerpJ, making them accessible from your Java code.

## Using Java's `JFileChooser` with CheerpJ

Java applications often use `JFileChooser` for "Save As..." dialogues. CheerpJ supports `JFileChooser`, and when a user selects a file name, that name is used within the virtual filesystem. You can then use this name to trigger a download using the native method approach described in Section 2.

When you instantiate `JFileChooser` in your Java code, it operates on CheerpJ's virtual filesystem. You instantiate it without arguments (`JFileChooser fileChooser = new JFileChooser();`), to open the dialog in the default directory: `/files/`.

Here is how the dialog will look like when you use `JFileChooser` in CheerpJ with the default `/files/` mount point:
![](/docs/cheerpj3/assets/filechooser.png)

**Java Source Code: Essential `JFileChooser` and Download Logic**

```java title="App.java"

// (Retain the native method declaration from Section 2)
public static native void downloadFileFromCheerpJ(String filePath);

// Button to trigger the JFileChooser
JButton chooseDownloadButton = new JButton("Choose File to Download");

chooseDownloadButton.addActionListener((ActionEvent e) -> {
    // 1. Instantiate JFileChooser, initially pointing to the /files/ mount point.
    JFileChooser fileChooser = new JFileChooser("/files/");
    fileChooser.setDialogTitle("Select file to download");
    // 2. Show the save dialog to let the user select a file.
    int result = fileChooser.showSaveDialog(this);
    // 3. Check if the user approved the selection (didn't cancel).
    if (result == JFileChooser.APPROVE_OPTION) {
        // 4. Get the selected file from the file chooser.
        // For example, if you wrote "Hello World" to /files/example.txt, "/files/example.txt" will be the selected file.
        // 5. Get the path of the selected file.
        File selectedFile = fileChooser.getSelectedFile();
        String filePath = selectedFile.getPath();
        // 6. Call the native JavaScript method to download the file from the virtual filesystem.
        downloadFileFromCheerpJ(filePath);
    }
});
```

**Explanation:**

- `new JFileChooser("/files/")`: This initializes the file chooser to start Browse from the `/files/` directory within CheerpJ's virtual filesystem. This is important because `/files/` is the writable and persistent mount point.
- `fileChooser.showSaveDialog(this)`: This method displays the file chooser dialog, allowing the user to select a save location and filename. `showOpenDialog` would be used for opening existing files.
- `fileChooser.getSelectedFile().getPath()`: If the user approves the selection, this returns the full path (e.g., `/files/myDocument.txt`) that the user specified.
- `downloadFileFromCheerpJ(filePath)`: We reuse the same native method from Section 2. Once the user has selected a path, you would ensure your Java application writes its data to that `filePath` within the virtual filesystem, and then you would call this native method to trigger the download to the user's local machine.

**HTML and JavaScript Code (`index.html`)**

The HTML and JavaScript for handling the download are essentially the **same as in Section 2**.

## Special Case: For Applets using `showDocument()`

For **Applets**, `AppletContext.showDocument()` can be used as a workaround for downloads, although native methods are generally more flexible.

- **Direct URL Download**: If the file you want to download is already available at a public URL (e.g., hosted on your server), you can simply use `showDocument()` to point to that URL, and the browser will handle the download.

  ```java
  // Java Applet Code
  private void downloadDirectURL() {
      try {
          // Assumes 'example.txt' is in the same directory as the applet JAR
          URL fileUrl = new URL(getCodeBase().getProtocol(),
                                getCodeBase().getHost(),
                                getCodeBase().getPort(),
                                "/example.txt");
          getAppletContext().showDocument(fileUrl, "_blank"); // "_blank" will trigger download
          System.out.println("Triggered direct URL download: " + fileUrl.toString());
      } catch (Exception ex) {
          ex.printStackTrace();
          JOptionPane.showMessageDialog(null, "Error downloading from URL: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
      }
  }
  ```

- **Executing JavaScript for Dynamic Content**: You can use `showDocument()` to execute arbitrary JavaScript code that then handles a download. This is less common but can be useful for passing dynamically generated content from Java to JavaScript for download.

  ```java
  // Java Applet Code
  private void downloadViaJavaScriptShowDocument() {
      try {
          String content = "Dynamic content generated in Java!";
          String encodedContent = URLEncoder.encode(content, "UTF-8").replace("+", "%20"); // Encode for URL
          AppletContext context = getAppletContext();
          // Call a JavaScript function 'downloadFromJava' and pass content
          context.showDocument(new URL("javascript:downloadFromJava('" + encodedContent + "')"));
          System.out.println("Triggered JS download via showDocument.");
      } catch (Exception ex) {
          ex.printStackTrace();
      }
  }
  ```

  And in your HTML, you'd have the `downloadFromJava` JavaScript function:

  ```javascript
  // JavaScript in applet.html
  function downloadFromJava(encodedContent) {
  	const content = decodeURIComponent(encodedContent);
  	const blob = new Blob([content], { type: "text/plain" });
  	const url = URL.createObjectURL(blob);

  	const a = document.createElement("a");
  	a.href = url;
  	a.download = "applet_showdocument_dynamic.txt";
  	document.body.appendChild(a);
  	a.click();
  	document.body.removeChild(a);
  	URL.revokeObjectURL(url);
  	console.log("File downloaded via showDocument (JS)");
  }
  ```
