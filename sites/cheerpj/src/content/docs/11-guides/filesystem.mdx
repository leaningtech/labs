---
title: Filesystem
description: Interacting with the virtual filesystem in CheerpJ
---

CheerpJ provides a **virtual filesystem** that lets your Java application read and write files inside a secure, browser-sandboxed environment. For browser security reasons, it cannot access the user’s actual local disk. All file operations happen within this virtual space.

> [!info] Mounting points overview
> - **`/app/`** — HTTP-based filesystem for loading files from your web server; **Write**: No, **Read**: Yes.
> - **`/files/`** — Persistent read–write filesystem (browser-scoped, e.g., IndexedDB); **Write**: Java only, **Read**: Yes.
> - **`/str/`** — Filesystem for passing JavaScript strings/binary data to Java; **Write**: JS only, **Read**: Yes.

> For a detailed overview of mounting points (`/app/`, `/files/`, `/str/`) and how they work, see the **[File and Filesystem guide](/docs/explanation/File-System-support)**.

## Loading the files from JavaScript to the Virtual File System

CheerpJ lets you make files available to Java by copying them into its virtual filesystem. Use `/files/` when the app expects files in its current working directory and can't change the logic. You can then open `"filename.txt"` with no prefix. Assets that are already part of your application live under `/app/` (read-only), so Java must reference them with the full path, e.g., `"/app/filename.txt"`.

### Method 1: Using `cheerpOSAddStringFile` (string or binary).

The quickest way to place a file into CheerpJ’s virtual filesystem from JavaScript is `cheerpOSAddStringFile`. It’s ideal for string content and also supports binary data.

**When to call it:** Invoke `cheerpOSAddStringFile` after `cheerpjInit()` finishes (i.e., once its Promise resolves). The API depends on the runtime and VFS being fully initialized.

**Where the file goes:** The call creates a file under the `/str/` mount. Your Java code can then read it like any normal file path inside the application.

```js
// Call this only after cheerpjInit() has resolved.
	async function addStringFileToCheerpJ() {
		const fileName = "default.txt";
		const content = "Default content.";

    try {
      await cheerpOSAddStringFile(`/str/${fileName}`, content);
      console.log(`File "${fileName}" added to /str/.`);
    } catch (e) {
      console.error("Error writing file to /str/:", e);
    }
	}
```

### Method 2: Using library mode

When a file already lives under `/app/` but your Java code needs to read it as if it were in `/files/` (i.e., without the `/app/` prefix), use library mode to copy it across mounts. With `cheerpjRunLibrary`, you can invoke Java’s `java.nio.file` from JavaScript to copy the file from `/app/…` to `/files/…`, after which the application can open it using just its bare filename.

```js
async function copyFileToFilesMountPoint() {
	// Library mode can be created before or after cheerpjInit
	const lib = await cheerpjRunLibrary(""); // Create a library mode object
	const Files = await lib.java.nio.file.Files;
	const StandardCopyOption = await lib.java.nio.file.StandardCopyOption;
	const Paths = await lib.java.nio.file.Paths;

	const source = await Paths.get("/app/notes_tmp.txt");
	const target = await Paths.get("/files/notes_tmp.txt");

	try {
		await Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING]);
		console.log("Copied /app/notes_tmp.txt to /files/notes_tmp.txt");
	} catch (e) {
		console.error("Error copying file:", e);
	}
}
```

## Getting a file from the Virtual File System to JavaScript (i.e local file system)

A common scenario is that your Java application generates or updates a file and you need to make it available to the user. When running under CheerpJ, files saved by Java are written to the virtual filesystem, specifically the `/files/` mount **not** directly to the user’s local disk. The workflow for exposing the file to the browser (and then the user) is as follows:

1. **Java writes/generates the file:** Your Java application creates or saves the file under the `/files/` mount within CheerpJ’s virtual filesystem.
2. **Java invokes a JavaScript native method:** Since the file lives in the virtual filesystem, we implement a Java **native** method that is handled by JavaScript. To learn more about native methods, you can refer to the [CheerpJ tutorial on native methods](/docs/guides/implementing-native-methods.html).
3. **JavaScript retrieves and processes the file:** In the JavaScript implementation of the native method, retrieve the file's content from the virtual filesystem. You can then process the file in any way required by your web application. For example you can trigger a download by using the `cjFileBlob()` API to get the file's content as a `Blob` and then use standard browser APIs to trigger a download (as will be explained in a later section).

**Step 1 and 2: Java Writes the File and Calls a Native Method**

First, your Java application writes the file to CheerpJ’s virtual filesystem (the `/files/` mount). Next it calls a **native method** (implemented in JavaScript), which acts as a bridge to execute JavaScript code.

```java title="App.java"
// Declare the native method
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
try {
    // You can also use "example.txt" since it defaults to the /files/ mount point
    File file = new File("/files/example.txt");
    FileWriter writer = new FileWriter(file);
    writer.write(content);
    writer.close();

    // Pass the actual file path to the native method
    downloadFileFromCheerpJ(filepath);

} catch (IOException e) {
    System.err.println("Error generating or writing file: " + e.getMessage());
}
```

**Step 3: JavaScript Implements the Native Method and Downloads the File**

Now we’ll implement the JavaScript for `downloadFileFromCheerpJ`. The function receives the file path from Java, uses CheerpJ’s `cjFileBlob()` to get the file’s content, and then triggers a download using standard browser APIs.

```html "index.html"
<script>
	// Native method implementation called from Java
	// Naming: Java_<fully-qualified-class>_<method>
	async function Java_com_App_downloadFileFromCheerpJ(
		lib, // CheerpJ's internal library object
		fileName // The file name passed from Java
	) {
		// fileName can be "example.txt" or "/files/example.txt" (both resolve to the /files/ mount)
		console.log(`Attempting to download file: ${fileName}`);

		try {
			// Read the file from CheerpJ's virtual filesystem as a Blob
			const blob = await cjFileBlob(`${fileName}`);

			// Create a temporary object URL for the Blob so the browser can download it
			const url = URL.createObjectURL(blob);

			// Create an anchor element and set the download target
			const a = document.createElement("a");
			a.href = url;

			// Use the last path segment as the download filename
			a.download = fileName.split("/").pop() || "download";

			// Add to the DOM, click it programmatically to start download, then remove
			document.body.appendChild(a);
			a.click();
			a.remove();

			// Clean up the temporary object URL
			URL.revokeObjectURL(url);

			console.log(`Successfully downloaded ${fileName}`);
		} catch (e) {
			console.error("Error downloading file:", e);
			alert("Failed to download the file. See console for details.");
		}
	}

	// Initialize CheerpJ and register the native method
	async function cj3init() {
		await cheerpjInit({
			// Register native method
			natives: { Java_com_App_downloadFileFromCheerpJ },
		});

		// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
	}
	cj3init();
</script>
```

**Explanation:**

- **Native method naming convention:** The JavaScript function name must follow `Java_<fully-qualified-class-name>_<method-name>` CheerpJ uses this pattern to bind a Java `native` method call to the correct JS implementation.
- **`cjFileBlob(filePath)`:** CheerpJ API that reads a file from the virtual filesystem (`/files/`, `/app/`, or `/str/`) and returns its contents as a `Blob`.
- **Blob and download flow:** After you have the `Blob`, use standard browser APIs to trigger a download:
  1. Create a temporary URL with `URL.createObjectURL(blob)`.
  2. Create an `<a>` element, set `a.href` to that URL.
  3. Set `a.download` to suggest the filename.
  4. Click the link programmatically to start the download.
  5. Call `URL.revokeObjectURL(...)` to release the temporary URL.
- **Registering natives in `cheerpjInit`:** Use the `natives` option to register your JavaScript native implementations so they’re callable from your Java code.

## Using Java's `JFileChooser` with CheerpJ

Many Java apps use `JFileChooser` for “Save As…” dialogs. CheerpJ supports `JFileChooser` and maps it to the **virtual filesystem**. When the user picks a filename, you get a VFS path (e.g., `/files/report.txt`). You can then pass that path to your **native method** to trigger a browser download as described in Section 2.

### How it behaves under CheerpJ

- The chooser operates in CheerpJ’s Virtual File System.
- The writable, persistent area is **`/files/`**.
- You can instantiate it with no arguments (`JFileChooser fileChooser = new JFileChooser();`), to open the dialog in the default directory: `/files/`

Here is how the dialog will look like when you use `JFileChooser` in CheerpJ with the default `/files/` mount point:
![](/docs/cheerpj3/assets/filechooser.png)

**Java Source Code: Essential `JFileChooser` and Download Logic**

```java title="App.java"
// Retain the native method declaration from Section 2
public static native void downloadFileFromCheerpJ(String filePath);

// UI control to open the chooser
JButton chooseDownloadButton = new JButton("Choose File to Download");

chooseDownloadButton.addActionListener((ActionEvent e) -> {
    // Instantiate JFileChooser, initially pointing to the /files/ mount point
    JFileChooser fileChooser = new JFileChooser("/files/");
    fileChooser.setDialogTitle("Select file to download");

    // Show a “Save” dialog to let the user select a file
    int result = fileChooser.showSaveDialog(this);

    // If user confirmed selection (didn't cancel)
    if (result == JFileChooser.APPROVE_OPTION) {
        // Resolve the chosen VFS path (e.g., "/files/example.txt")
        File selectedFile = fileChooser.getSelectedFile();
        String filePath = selectedFile.getPath();

        // Trigger the browser download via the native JavaScript method
        downloadFileFromCheerpJ(filePath);
    }
});
```

**Explanation:**

- **`new JFileChooser("/files/")`:** Initializes the chooser rooted at `/files/` in CheerpJ’s virtual filesystem. This is the writable and persistent mount point.
- **`fileChooser.showSaveDialog(this)`:** Displays the “Save” dialog so the user can pick a filename and location. _(Use `showOpenDialog(this)` when you want the user to select an existing file to open.)_
- **`fileChooser.getSelectedFile().getPath()`:** If the user confirms, returns the full VFS path they chose (e.g., `/files/myDocument.txt`).
- **`downloadFileFromCheerpJ(filePath)`:** Invokes the JavaScript native method from Section 2. Pass it the VFS path (`filePath`), where the JavaScript side reads the file via `cjFileBlob(...)` and triggers a standard browser download to the user’s machine.

**HTML and JavaScript Code (`index.html`)** for handling the download are essentially the **same as in Section 2**.

## Special Case: Applets using `showDocument()`

For **Applets**, `AppletContext.showDocument()` can be used as a lightweight workaround to trigger downloads. This can be handy, but the **native-method approach** remains more flexible and robust for most cases.

### Option A: Direct URL download

If the file is already available at a public URL (e.g., on your server), point `showDocument()` at that URL and let the browser handle the download.

```java
// Java Applet Code
private void downloadDirectURL() {
    try {
        // Assumes 'example.txt' is in the same directory as the applet JAR
        URL fileUrl = new URL(getCodeBase().getProtocol(),
                              getCodeBase().getHost(),
                              getCodeBase().getPort(),
                              "/example.txt");
        getAppletContext().showDocument(fileUrl, "_blank"); // "_blank" will trigger download
        System.out.println("Triggered direct URL download: " + fileUrl.toString());
    } catch (Exception ex) {
        ex.printStackTrace();
        JOptionPane.showMessageDialog(null, "Error downloading from URL: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
    }
}
```

### Option B: Execute JavaScript for dynamic content

You can use `showDocument()` to execute arbitrary JavaScript code that then handles a download. This is less common but can be useful for passing dynamically generated content from Java to JavaScript for download.

```java
// Java Applet Code
private void downloadViaJavaScriptShowDocument() {
    try {
        String content = "Dynamic content generated in Java!";
        String encodedContent = URLEncoder.encode(content, "UTF-8").replace("+", "%20"); // Encode for URL
        AppletContext context = getAppletContext();
        // Call a JavaScript function 'downloadFromJava' and pass content
        context.showDocument(new URL("javascript:downloadFromJava('" + encodedContent + "')"));
        System.out.println("Triggered JS download via showDocument.");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}
```

And in your HTML, you'd have the `downloadFromJava` JavaScript function:

```javascript
// JavaScript in applet.html
function downloadFromJava(encodedContent) {
	const content = decodeURIComponent(encodedContent);
	const blob = new Blob([content], { type: "text/plain" });
	const url = URL.createObjectURL(blob);

	const a = document.createElement("a");
	a.href = url;
	a.download = "applet_showdocument_dynamic.txt";
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
	URL.revokeObjectURL(url);
	console.log("File downloaded via showDocument (JS)");
}
```
