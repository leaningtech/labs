---
title: Filesystem
description: Interacting with the virtual filesystem in CheerpJ
---

CheerpJ provides a **virtual filesystem** that lets your Java application read and write files inside a secure, browser-sandboxed environment. For browser security reasons, it cannot access the user’s actual local disk. All file operations happen within this virtual space, which provides multiple mounting points so your application can behave much like it would on a regular filesystem.

Mounting points overview
- **`/app/`** — Read-only mount mapping to your web server’s root (HTTP assets). Java can read the files using the '/app/' prefix.
- **`/files/`** — Persistent, Java read-write area and the default mounting point for Java. JavaScript can read via CheerpJ APIs.
- **`/str/`** — Accessible mount used to pass data from JavaScript to Java. JavaScript can read and write, Java can only read. Not persisted.

> For a detailed overview of mounting points (`/app/`, `/files/`, `/str/`) and how they work, see the **[File and Filesystem guide](/docs/explanation/File-System-support)**.

## Loading Files from JavaScript into the Virtual Filesystem

CheerpJ lets you make files available to Java by copying them into its virtual filesystem. Use `/files/` when the app expects files in its current working directory and can't change the logic. You can then open `"filename.txt"` with no prefix. Assets that are already part of your application live under `/app/` (read-only), so Java must reference them with the full path, e.g., `"/app/filename.txt"`.

CheerpJ offers multiple ways to move files into its virtual file system. The next section walks through the most common approaches.

### Method 1: Using `cheerpOSAddStringFile` (string or binary).

The quickest way to place a file into CheerpJ’s virtual filesystem from JavaScript is `cheerpOSAddStringFile`. It’s ideal for string content and also supports binary data.

**When to call it:** Invoke `cheerpOSAddStringFile` after `cheerpjInit()` finishes (i.e., once its Promise resolves). The API depends on the runtime and virtual file system being fully initialized.

**Where the file goes:** The call creates a file under the `/str/` mount. Your Java code can then read it like any normal file path inside the application.

```js
// Call this only after cheerpjInit() has resolved.
async function addStringFileToCheerpJ() {
	const fileName = "default.txt";
	const content = "Default content.";

	try {
		await cheerpOSAddStringFile(`/str/${fileName}`, content);
		console.log(`File "${fileName}" added to /str/.`);
	} catch (e) {
		console.error("Error writing file to /str/:", e);
	}
}
```

Entries you create under **`/str/`** (from JavaScript) are readable from Java as regular files. Remember: `/str/` is **not persisted** and is **read-only** from Java.

```java title="App.java"
import java.nio.file.Files;
import java.nio.file.Path;
/*
Rest of your Java code...
*/
String text = Files.readString(Path.of("/str/fileName.txt"));
System.out.println(text);
```

### Method 2: Using library mode

When a file already lives under `/app/` but your Java code needs to read it as if it were in `/files/` (i.e., without the `/app/` prefix), use library mode to copy it across mounts. With `cheerpjRunLibrary`, you can invoke Java’s `java.nio.file` from JavaScript to copy the file from `/app/…` to `/files/…`, after which the application can open it using just its bare filename.

> You can read more about library mode in the [CheerpJ Native Libraries documentation](/docs/reference/cheerpjRunLibrary).

```js
async function copyFileToFilesMountPoint() {
	// Library mode can be created before or after cheerpjInit
	const lib = await cheerpjRunLibrary(""); // Create a library mode object
	const Files = await lib.java.nio.file.Files;
	const StandardCopyOption = await lib.java.nio.file.StandardCopyOption;
	const Paths = await lib.java.nio.file.Paths;

	const source = await Paths.get("/app/notes_tmp.txt");
	const target = await Paths.get("/files/notes_tmp.txt");

	try {
		await Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING]);
		console.log("Copied /app/notes_tmp.txt to /files/notes_tmp.txt");
	} catch (e) {
		console.error("Error copying file:", e);
	}
}

// Then, initialize CheerpJ and run your Java application
async function cj3init() {
	await cheerpjInit({
		version: 8,
	});
	// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}
cj3init();
copyFileToFilesMountPoint();
// Your Java app can now access "notes_tmp.txt" by simply calling `new File("notes_tmp.txt")`
// without needing the /app/ prefix.
```

## Getting a file from the Virtual File System to JavaScript (i.e local file system)

When Java runs under CheerpJ, files are saved in the virtual filesystem (defaults under **`/files/`**), not directly to the user’s disk. Use the JavaScript-accessible [cjFileBlob API](/docs/reference/cjFileBlob) to extract files from the virtual file system. For a more seamless flow, define a [Native Methods](/docs/guides/implementing-native-methods) implemented in JavaScript to process the file. This can look like:

1. Java writes/generates the file (e.g., under **`/files/`**).
2. Java invokes a JavaScript **native method**.
3. JavaScript reads the file from the virtual file system and processes it (e.g., create a `Blob` and trigger a download).

**Step 1 and 2: Java Writes the File and Calls a Native Method**

First, your Java application writes the file to CheerpJ’s virtual filesystem (the `/files/` mount). Next it calls a **native method** (implemented in JavaScript), which acts as a bridge to execute JavaScript code.

```java title="App.java"
// Declare the native method
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
try {
    // You can also use "example.txt" since it defaults to the /files/ mount point
    File file = new File("/files/example.txt");
    FileWriter writer = new FileWriter(file);
    writer.write(content);
    writer.close();

    // Pass the actual file path to the native method
    downloadFileFromCheerpJ(filepath);

} catch (IOException e) {
    System.err.println("Error generating or writing file: " + e.getMessage());
}
```

**Step 3: JavaScript Implements the Native Method and Downloads the File**

Now we’ll implement the JavaScript for `downloadFileFromCheerpJ`. The function receives the file path from Java, uses CheerpJ’s `cjFileBlob()` to get the file’s content, and then triggers a download using standard browser APIs.

```js
// Native method implementation called from Java
// Naming: Java_<fully-qualified-class>_<method>
async function Java_App_downloadFileFromCheerpJ(lib, fileName) {
	try {
		// Read the file from CheerpJ's virtual filesystem as a Blob
		const blob = await cjFileBlob("/files/" + fileName);

		// Create an invisible link
		const link = document.createElement("a");
		link.href = URL.createObjectURL(blob);
		link.download = fileName;

		// Simulate a click on the link and clean up objects
		link.click();
		link.remove();
		URL.revokeObjectURL(url);

		console.log(`Successfully downloaded ${fileName}`);
	} catch (e) {
		console.error("Error downloading file:", e);
	}
}

// Initialize CheerpJ and register the native method
async function cj3init() {
	await cheerpjInit({
		// Register native method
		natives: { Java_App_downloadFileFromCheerpJ },
	});
	// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}
cj3init();
```

## Using Java's `JFileChooser` with CheerpJ

`JFileChooser` works the same under CheerpJ, but it targets the **virtual filesystem**. By default the dialog opens in `/files/` mount (the writable, persistent area), so any file you open or save is referenced by a virtual file system path (e.g., /files/report.txt) rather than the user’s physical disk.

Here is how the dialog will look like when you use `JFileChooser` in CheerpJ with the default `/files/` mount point:
![](/docs/cheerpj3/assets/filechooser.png)

You can still perform normal Java file operations with CheerpJ. The paths simply refer to the virtual filesystem rather than the user’s physical disk.

To access local files, first import them into the virtual file system (see previous section). To save or download files to the user’s machine from Java, you can utilize a JavaScript native method again.

**Java Source Code: Essential `JFileChooser` and Download Logic**

```js title="App.java"
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
JFileChooser fileChooser = new JFileChooser();
int result = fileChooser.showOpenDialog(null);

// User confirmed file selection
if (result == JFileChooser.APPROVE_OPTION) {
  File selectedFile = fileChooser.getSelectedFile();
  String filePath = selectedFile.getPath();

  // Trigger the native JavaScript function that handles the file
  downloadFileFromCheerpJ(filePath);
}
```

The JavaScript code for handling the download is essentially the same as the Step 3 code of **[Getting the file from the virtual file system to JavaScript](/docs/guides/filesystem#getting-a-file-from-the-virtual-file-system-to-javascript-ie-local-file-system)**.

## Special Case: Applets using `showDocument()`

For **Applets**, `AppletContext.showDocument()` can be used as a lightweight workaround to trigger downloads. This can be handy, but the **native-method approach** remains more flexible and robust for most cases.

### Option A: Direct URL download

If the file is already available at a public URL (e.g., on your server), point `showDocument()` at that URL.

```java
// Java Applet Code
private void downloadDirectURL() {
  try {
    // Assumes 'filename.txt' is in the same directory as the applet JAR
    URL fileUrl = new URL(getCodeBase()+"filename.txt");
    getAppletContext().showDocument(fileUrl, "_blank");

    System.out.println("Triggered direct URL download: " + fileUrl.toString());
  } catch (Exception ex) {
    ex.printStackTrace();
    JOptionPane.showMessageDialog(null, "Error downloading from URL: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
  }
}
```

### Option B: Execute JavaScript for dynamic content

You can use `showDocument()` to execute arbitrary JavaScript code that then handles a download. This is less common but can be useful for passing dynamically generated content from Java to JavaScript for download.

```java
// Java Applet Code
private void downloadViaJavaScriptShowDocument() {
  try {
      String content = "Dynamic content generated in Java!";
      String encodedContent = URLEncoder.encode(content, "UTF-8").replace("+", "%20"); // Encode for URL
      AppletContext context = getAppletContext();

      // Call a JavaScript function 'downloadFromJava' and pass content
      context.showDocument(new URL("javascript:downloadFromJava('" + encodedContent + "')"));
      System.out.println("Triggered JS download via showDocument.");
  } catch (Exception ex) {
      ex.printStackTrace();
  }
}
```

And in your HTML, you'd have the `downloadFromJava` JavaScript function:

```javascript
// JavaScript in applet.html
function downloadFromJava(encodedContent) {
	try {
		const content = decodeURIComponent(encodedContent);
		const blob = new Blob([content], { type: "text/plain" });
		const url = URL.createObjectURL(blob);

		// Create an invisible link
		const link = document.createElement("a");
		link.href = url;
		link.download = "applet_showdocument_dynamic.txt";

		// Simulate a click on the link and clean up objects
		link.click();
		link.remove();
		URL.revokeObjectURL(url);

		console.log("File downloaded via showDocument");
	} catch (e) {
		console.error("Error downloading file:", e);
	}
}
```
