---
title: Filesystem
description: Interacting with the virtual filesystem in CheerpJ
---

CheerpJ provides a **virtual filesystem** that allows your Java applications to perform file operations like reading and writing, just as they would on a desktop. This guide will explain how to effectively use CheerpJ's virtual filesystem, demonstrating how to transfer files between your Java application and the local JavaScript environment by focusing on common use cases.

> For a detailed overview of mounting points (`/app/`, `/files/`, `/str/`) and how they work, see the **[File and Filesystem guide](/docs/explanation/File-System-support)**.

> [!info] Local files
> CheerpJ provides access to a virtualized filesystem, which does not correspond to the local user's computer. For browser security reasons, direct access to local files is forbidden. This means your Java code running in CheerpJ cannot directly read or write files on the user's physical hard drive. All file interactions happen within this secure, virtual environment.

## Loading the files from JavaScript to the Virtual File System

Sometimes, your web page may have files (for example, uploaded by a user) that your Java application needs to read or process. You can transfer these files from JavaScript into CheerpJ’s virtual file system. This is useful in several scenarios:

- **External Applications:** Some Java applications expect files in specific paths (e.g., a hardcoded path like `filename.txt`). If you load a file into `/app/`, your Java code must reference it as `/app/filename.txt`. But if you can’t modify the Java code, for example in an external application, loading the file into `/files/` makes it accessible simply as `"filename.txt"`. The `/files/` directory acts as a default working directory.
- **Dynamic Content:** You can provide configuration files or other runtime data from JavaScript directly to your Java application, without recompiling or modifying the Java code.
- **Binary Data:** The `cheerpOSAddStringFile` API (and the underlying `java.nio.file.Files.copy` method) supports binary files as well, allowing you to provide any file type to Java.

### Method 1: Using `cheerpOSAddStringFile` (string or binary).

The quickest way to place a file into CheerpJ’s virtual filesystem from JavaScript is `cheerpOSAddStringFile`. It’s ideal for string content and also supports binary data.

**When to call it:** Invoke `cheerpOSAddStringFile` after `cheerpjInit()` finishes (i.e., once its Promise resolves). The API depends on the runtime and VFS being fully initialized.

**Where the file goes:** The call creates a file under the `/str/` mount. Your Java code can then read it like any normal file path inside the application.

```js
// Call this only after cheerpjInit() has resolved.
async function addStringFileToCheerpJ() {
	const fileName =
		document.getElementById("jsFileName").value.trim() || "default.txt";
	const content =
		document.getElementById("jsFileContent").value || "Default content.";
	const messageDiv = document.getElementById("jsMessage");

	try {
		// Using cheerpOSAddStringFile to add content to /str/
		await cheerpOSAddStringFile(`/str/${fileName}`, content);
		messageDiv.textContent = `Saved /str/${fileName}. (overwrites if existing)`;
		console.log(`Saved ${fileName} to /str/`);
	} catch (e) {
		messageDiv.textContent = `Failed to save /str/${fileName}: ${e.message}`;
		console.error("Error Writing file to /str/:", e);
	}
}
```

### Method 2: Using library mode

When a file already lives under `/app/` but your Java code needs to read it as if it were in `/files/` (i.e., without the `/app/` prefix), use library mode to copy it across mounts. With `cheerpjRunLibrary`, you can invoke Java’s `java.nio.file` from JavaScript to copy the file from `/app/…` to `/files/…`, after which the application can open it using just its bare filename.

```js
async function copyFileToFilesMountPoint() {
	// Library mode can be created before or after cheerpjInit
	const lib = await cheerpjRunLibrary(""); // Create a library mode object
	const Files = await lib.java.nio.file.Files;
	const StandardCopyOption = await lib.java.nio.file.StandardCopyOption;
	const Paths = await lib.java.nio.file.Paths;

	// Source is a file within the /app/ mount point
	const source = await Paths.get("/app/notes_tmp.txt");
	// Target is the /files/ mount point
	const target = await Paths.get("/files/notes_tmp.txt");

	try {
		await Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING]);
		console.log("Copied /app/notes_tmp.txt to /files/notes_tmp.txt");
	} catch (e) {
		console.error("Error copying file:", e);
	}
}

// Initializing CheerpJ and run your Java Application
async function cj3init() {
	await cheerpjInit({ version: 8 });
	// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
}

(async () => {
	await cj3init();
	await copyFileToFilesMountPoint();
})();

// Your Java app can now access "notes_tmp.txt" by simply calling `new File("notes_tmp.txt")`
// without needing the /app/ prefix.
```

**Explanation:**

- **`cheerpjRunLibrary("")`** Creates a library-mode object that lets you call Java’s `java.nio.file` APIs from JavaScript. See the [CheerpJ documentation](/docs/reference/cheerpjRunLibrary) for details.
- **`Files.copy(source, target, [StandardCopyOption.REPLACE_EXISTING])`** Copies a file from the `/app/` mount point to the `/files/` mount point. Using `REPLACE_EXISTING` ensures the target is overwritten if it already exists.
- **Accessing the file in Java:** After copying, your Java application can read it with `new File("notes_tmp.txt")`. No /app/ prefix is needed once the file is in /files/.

## Getting a file from the Virtual File System to JavaScript (i.e local file system)

A common scenario is that your Java application generates or updates a file and you need to make it available to the user. When running under CheerpJ, files saved by Java are written to the virtual filesystem, specifically the `/files/` mount **not** directly to the user’s local disk. The workflow for exposing the file to the browser (and then the user) is as follows:

1. **Java writes/generates the file:** Your Java application creates or saves the file under the `/files/` mount within CheerpJ’s virtual filesystem.
2. **Java invokes a JavaScript native method:** Since the file lives in the virtual filesystem, we implement a Java **native** method that is handled by JavaScript. To learn more about native methods, you can refer to the [CheerpJ tutorial on native methods](/docs/guides/implementing-native-methods.html).
3. **JavaScript retrieves and processes the file:** In the JavaScript implementation of the native method, retrieve the file's content from the virtual filesystem. You can then process the file in any way required by your web application. For example you can trigger a download by using the `cjFileBlob()` API to get the file's content as a `Blob` and then use standard browser APIs to trigger a download (as will be explained in a later section).

**Step 1 and 2: Java Writes the File and Calls a Native Method**

First, your Java application writes the file to CheerpJ’s virtual filesystem (the `/files/` mount). Next it calls a **native method** (implemented in JavaScript), which acts as a bridge to execute JavaScript code.

```java title="App.java"
// Declare the native method
public static native void downloadFileFromCheerpJ(String filePath);
/*
Rest of your Java code...
*/
try {
    // You can also use "example.txt" since it defaults to the /files/ mount point
    File file = new File("/files/example.txt");
    FileWriter writer = new FileWriter(file);
    writer.write(content);
    writer.close();

    // Pass the actual file path to the native method
    downloadFileFromCheerpJ(filepath);

} catch (IOException e) {
    System.err.println("Error generating or writing file: " + e.getMessage());
}
```

**Step 3: JavaScript Implements the Native Method and Downloads the File**

Now we’ll implement the JavaScript for `downloadFileFromCheerpJ`. The function receives the file path from Java, uses CheerpJ’s `cjFileBlob()` to get the file’s content, and then triggers a download using standard browser APIs.

```html "index.html"
<script>
	// Native method implementation called from Java
	// Naming: Java_<fully-qualified-class>_<method>
	async function Java_com_App_downloadFileFromCheerpJ(
		lib, // CheerpJ's internal library object
		fileName // The file name passed from Java
	) {
		// fileName can be "example.txt" or "/files/example.txt" (both resolve to the /files/ mount)
		console.log(`Attempting to download file: ${fileName}`);

		try {
			// Read the file from CheerpJ's virtual filesystem as a Blob
			const blob = await cjFileBlob(`${fileName}`);

			// Create a temporary object URL for the Blob so the browser can download it
			const url = URL.createObjectURL(blob);

			// Create an anchor element and set the download target
			const a = document.createElement("a");
			a.href = url;

			// Use the last path segment as the download filename
			a.download = fileName.split("/").pop() || "download";

			// Add to the DOM, click it programmatically to start download, then remove
			document.body.appendChild(a);
			a.click();
			a.remove();

			// Clean up the temporary object URL
			URL.revokeObjectURL(url);

			console.log(`Successfully downloaded ${fileName}`);
		} catch (e) {
			console.error("Error downloading file:", e);
			alert("Failed to download the file. See console for details.");
		}
	}

	// Initialize CheerpJ and register the native method
	async function cj3init() {
		await cheerpjInit({
			// Register native method
			natives: { Java_com_App_downloadFileFromCheerpJ },
		});

		// cheerpjCreateDisplay(...) and cheerpjRunMain(...) go here
	}
	cj3init();
</script>
```

**Explanation:**

- **Native method naming convention:** The JavaScript function name must follow `Java_<fully-qualified-class-name>_<method-name>` CheerpJ uses this pattern to bind a Java `native` method call to the correct JS implementation.
- **`cjFileBlob(filePath)`:** CheerpJ API that reads a file from the virtual filesystem (`/files/`, `/app/`, or `/str/`) and returns its contents as a `Blob`.
- **Blob and download flow:** After you have the `Blob`, use standard browser APIs to trigger a download:
  1. Create a temporary URL with `URL.createObjectURL(blob)`.
  2. Create an `<a>` element, set `a.href` to that URL.
  3. Set `a.download` to suggest the filename.
  4. Click the link programmatically to start the download.
  5. Call `URL.revokeObjectURL(...)` to release the temporary URL.
- **Registering natives in `cheerpjInit`:** Use the `natives` option to register your JavaScript native implementations so they’re callable from your Java code.

## Using Java's `JFileChooser` with CheerpJ

Many Java apps use `JFileChooser` for “Save As…” dialogs. CheerpJ supports `JFileChooser` and maps it to the **virtual filesystem**. When the user picks a filename, you get a VFS path (e.g., `/files/report.txt`). You can then pass that path to your **native method** to trigger a browser download as described in Section 2.

### How it behaves under CheerpJ

- The chooser operates in CheerpJ’s Virtual File System.
- The writable, persistent area is **`/files/`**.
- You can instantiate it with no arguments (`JFileChooser fileChooser = new JFileChooser();`), to open the dialog in the default directory: `/files/`

Here is how the dialog will look like when you use `JFileChooser` in CheerpJ with the default `/files/` mount point:
![](/docs/cheerpj3/assets/filechooser.png)

**Java Source Code: Essential `JFileChooser` and Download Logic**

```java title="App.java"
// Retain the native method declaration from Section 2
public static native void downloadFileFromCheerpJ(String filePath);

// UI control to open the chooser
JButton chooseDownloadButton = new JButton("Choose File to Download");

chooseDownloadButton.addActionListener((ActionEvent e) -> {
    // Instantiate JFileChooser, initially pointing to the /files/ mount point
    JFileChooser fileChooser = new JFileChooser("/files/");
    fileChooser.setDialogTitle("Select file to download");

    // Show a “Save” dialog to let the user select a file
    int result = fileChooser.showSaveDialog(this);

    // If user confirmed selection (didn't cancel)
    if (result == JFileChooser.APPROVE_OPTION) {
        // Resolve the chosen VFS path (e.g., "/files/example.txt")
        File selectedFile = fileChooser.getSelectedFile();
        String filePath = selectedFile.getPath();

        // Trigger the browser download via the native JavaScript method
        downloadFileFromCheerpJ(filePath);
    }
});
```

**Explanation:**

- **`new JFileChooser("/files/")`:** Initializes the chooser rooted at `/files/` in CheerpJ’s virtual filesystem. This is the writable and persistent mount point.
- **`fileChooser.showSaveDialog(this)`:** Displays the “Save” dialog so the user can pick a filename and location. _(Use `showOpenDialog(this)` when you want the user to select an existing file to open.)_
- **`fileChooser.getSelectedFile().getPath()`:** If the user confirms, returns the full VFS path they chose (e.g., `/files/myDocument.txt`).
- **`downloadFileFromCheerpJ(filePath)`:** Invokes the JavaScript native method from Section 2. Pass it the VFS path (`filePath`), where the JavaScript side reads the file via `cjFileBlob(...)` and triggers a standard browser download to the user’s machine.

**HTML and JavaScript Code (`index.html`)** for handling the download are essentially the **same as in Section 2**.

## Special Case: Applets using `showDocument()`

For **Applets**, `AppletContext.showDocument()` can be used as a lightweight workaround to trigger downloads. This can be handy, but the **native-method approach** remains more flexible and robust for most cases.

### Option A: Direct URL download

If the file is already available at a public URL (e.g., on your server), point `showDocument()` at that URL and let the browser handle the download.

```java
// Java Applet Code
private void downloadDirectURL() {
    try {
        // Assumes 'example.txt' is in the same directory as the applet JAR
        URL fileUrl = new URL(getCodeBase().getProtocol(),
                              getCodeBase().getHost(),
                              getCodeBase().getPort(),
                              "/example.txt");
        getAppletContext().showDocument(fileUrl, "_blank"); // "_blank" will trigger download
        System.out.println("Triggered direct URL download: " + fileUrl.toString());
    } catch (Exception ex) {
        ex.printStackTrace();
        JOptionPane.showMessageDialog(null, "Error downloading from URL: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
    }
}
```

### Option B: Execute JavaScript for dynamic content

You can use `showDocument()` to execute arbitrary JavaScript code that then handles a download. This is less common but can be useful for passing dynamically generated content from Java to JavaScript for download.

```java
// Java Applet Code
private void downloadViaJavaScriptShowDocument() {
    try {
        String content = "Dynamic content generated in Java!";
        String encodedContent = URLEncoder.encode(content, "UTF-8").replace("+", "%20"); // Encode for URL
        AppletContext context = getAppletContext();
        // Call a JavaScript function 'downloadFromJava' and pass content
        context.showDocument(new URL("javascript:downloadFromJava('" + encodedContent + "')"));
        System.out.println("Triggered JS download via showDocument.");
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}
```

And in your HTML, you'd have the `downloadFromJava` JavaScript function:

```javascript
// JavaScript in applet.html
function downloadFromJava(encodedContent) {
	const content = decodeURIComponent(encodedContent);
	const blob = new Blob([content], { type: "text/plain" });
	const url = URL.createObjectURL(blob);

	const a = document.createElement("a");
	a.href = url;
	a.download = "applet_showdocument_dynamic.txt";
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
	URL.revokeObjectURL(url);
	console.log("File downloaded via showDocument (JS)");
}
```
