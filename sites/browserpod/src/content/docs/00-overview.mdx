---
title: BrowserPod
shortTitle: Overview
description: A universal execution layer for running code safely in the browser
---

import LinkButton from "@leaningtech/astro-theme/components/LinkButton.astro";
import { DISCORD_URL } from "@/consts.ts";

    <div class="%BP_LATEST%"
    />

<div class="not-prose flex gap-2 mb-2">
	<img
		src="https://img.shields.io/badge/version-%BP_LATEST%-orange"
		alt="Version %BP_LATEST%"
	/>
	<a href="https://discord.leaningtech.com/">
		<img
			src="https://img.shields.io/discord/988743885121548329?color=%237289DA&logo=discord&logoColor=ffffff"
			alt="Discord server"
		/>
	</a>
	<a href="https://github.com/leaningtech/browserpod-meta/issues">
		<img
			src="https://img.shields.io/github/issues/leaningtech/browserpod-meta.svg?logo=github"
			alt="GitHub issues"
		/>
	</a>
</div>

**BrowserPod** is a universal execution layer for browser-based compute, providing a sandboxed runtime API for running full-stack workloads directly inside the browser.
Instead of provisioning a cloud server, BrowserPod's API enables a client browser to host full runtimes compiled to WebAssembly (Wasm), running at near native speed.

<div class="m-4 flex justify-center">
	[Get started](/docs/getting-started/quickstart) · [Basic
	Tutorial](/docs/getting-started/expressjs) · [API reference](/docs/reference)
	· [GitHub repository](https://github.com/leaningtech/browserpod-meta) ·
	[Licensing](/docs/more/licensing)
</div>

BrowserPod is ephemeral by design. Each **pod** (_see [pod](/docs/more/glossary#pod)_) runs inside a browser tab and ends when the tab closes or reloads. Because BrowserPod runs inside the browser, each Pod is constrained by the browser’s security model, isolated from the user’s OS, with limited access (via syscalls) to local files or system resources unless you explicitly provide it.

At a high level, BrowserPod gives you:

- A **sandboxed runtime** for executing untrusted code in the browser (starting with Node.js, with Python, Ruby, Go, and Rust coming soon)
- A block-based streaming virtual filesystem with familiar file and directory behavior
- **Process isolation** and true concurrency via WebWorkers
- **Portals** for controlled networking that expose services at shareable URLs

Everything runs client‑side within the browser sandbox, with no backend infrastructure required.

## What you can do with BrowserPod

- **Execute AI-generated code safely**: Run code produced by AI agents or models in a contained environment next to the user, with fast startup, strong isolation, and better performance than cloud-based sandboxes. Reduce per-session costs while tightening security boundaries.
- **Build web-based IDEs and development environments**: Power real development workflows in the browser with package installs, dev servers, build tools, and previews—all with high fidelity to native environments.
- **Create interactive documentation and live demos**: Turn documentation into runnable environments where users can modify, execute, and share examples without leaving the page or provisioning infrastructure.
- **Enable education at scale**: Provide high-fidelity learning environments with minimal operational overhead. Eliminate per-student sandbox costs to make hands-on education economically feasible at scale.
- **Process sensitive data locally**: Keep user inputs and outputs in the browser by default, enabling privacy-first applications and removing jurisdictional risks associated with cloud data transfer.

## Why pick the BrowserPod API?

- **Economics**: BrowserPod runs on the user's device, eliminating per-session cloud infrastructure costs. This fundamental shift makes previously expensive use cases—like AI code execution, interactive demos, and education at scale—economically viable.
- **Latency**: No cold starts, no network round trips to remote sandboxes. Code executes immediately in the browser where the user already is.
- **Security & data locality**: BrowserPod inherits the browser's battle-tested security model. User data and code execution stay local by default, reducing your attack surface and compliance burden.
- **High fidelity**: Full Linux-compliant environment with POSIX filesystem, process isolation, and real concurrency—not a limited simulation. Run actual frameworks and tools without modification.
- **Portals**: Share working applications instantly via secure, temporary URLs. Enable live previews, collaborative troubleshooting, and interactive demos without standing up dedicated infrastructure.

## How it works (high level)

- BrowserPod provides complete runtime engines (starting with Node.js) compiled to WebAssembly, targeting a Linux-compliant syscall interface.
- The browser's JavaScript engine executes the runtime with near-native performance, supporting real multi-process workloads.
- A virtual filesystem provides full POSIX compatibility, with on-demand streaming of disk images. Changes stay local and can persist across sessions.
- When your code listens on a port, BrowserPod automatically creates a Portal—a secure URL that routes external traffic to the service running inside the browser.
- All execution happens within the browser's security sandbox, isolated from the user's operating system.

See the [hosting guide](/docs/guides/hosting) for details on headers and setup.

## Supported runtimes

BrowserPod currently supports Node.js. Python, Ruby, Go, and Rust support will be released throughout 2026. By the end of 2026, BrowserPod will support Linux-class workloads, enabling any Linux container to run in the browser.

## Community and support

<LinkButton
	type="discord"
	href={DISCORD_URL}
	iconLeft="fa-brands:discord"
	label="Join our Discord server"
/>

<LinkButton
	type="secondary"
	href="https://twitter.com/leaningtech"
	iconLeft="fa-brands:twitter"
	label="Follow us on Twitter"
/>

---
